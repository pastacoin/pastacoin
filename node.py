import json
import os
import threading
import time
import requests
from flask import Flask, request, jsonify
import argparse

# Assuming fake-blockchain-gen.py and fake-mempool-gen.py might still be used
# initially to create the baseline files.
NETWORK_PATH = "C:\\PastaNetwork" # Keep for loading initial files, maybe remove later

def load_json(filename: str, default):
    # Load from the shared path for initial setup
    filepath = os.path.join(NETWORK_PATH, filename)
    if os.path.exists(filepath):
        try:
            with open(filepath, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Error decoding JSON from {filename}. Starting with default.")
            return default
    print(f"Warning: {filename} not found. Starting with default.")
    return default

class PastaNode:
    def __init__(self, port: int, peers: list[str]):
        self.port = port
        self.address = f"http://localhost:{port}" # Node's own address for identification
        self.peers = set(peers) # Known peer addresses (e.g., 'http://localhost:5001')

        # --- Node's Internal State ---
        # Load initial state from files generated by fake scripts
        self.blockchain = load_json("blockchain.json", [])
        self.mempool = load_json("mempool.json", []) # Initial mempool from file
        self.addresses = load_json("addresses.json", {}) # Maps public key to private key

        # Basic locking for thread safety
        self.lock = threading.Lock()

        print(f"Node initialized on port {self.port} at address {self.address}")
        print(f"Initial Blockchain size: {len(self.blockchain)}")
        print(f"Initial Mempool size: {len(self.mempool)}")
        print(f"Known addresses: {len(self.addresses)}")
        print(f"Known peers: {self.peers}")

    def _broadcast_transaction(self, transaction: dict):
        """Broadcasts a transaction to all known peers."""
        with self.lock: # Ensure peers set doesn't change during iteration
            peers_to_broadcast = list(self.peers)

        if not peers_to_broadcast:
            print("No peers to broadcast to.")
            return

        print(f"Broadcasting transaction {transaction.get('signature')[:8]}... to peers: {peers_to_broadcast}")
        headers = {'Content-Type': 'application/json', 'X-Pasta-Origin': self.address}
        for peer in peers_to_broadcast:
            try:
                # Use a timeout to prevent hanging indefinitely
                response = requests.post(f"{peer}/add_transaction", headers=headers, json=transaction, timeout=1)
                response.raise_for_status()
                print(f"  -> Sent to {peer}, status {response.status_code}")
            except requests.exceptions.Timeout:
                print(f"  -> Timeout sending to {peer}")
            except requests.exceptions.RequestException as e:
                print(f"  -> Failed sending to {peer}: {e}")
            except Exception as e:
                 print(f"  -> Unexpected error sending to {peer}: {e}")


    def add_transaction_to_mempool(self, transaction: dict, origin_peer: str = None) -> bool:
        """Adds a transaction to the mempool if valid and broadcasts if it's new."""
        tx_signature = transaction.get('signature')
        if not tx_signature:
            print("Transaction missing signature.")
            return False

        with self.lock:
            # Duplicate check
            if any(tx.get('signature') == tx_signature for tx in self.mempool):
                if not origin_peer:
                    print(f"Transaction {tx_signature[:8]}... already in mempool.")
                return False

            # Set predecessor information for new transactions
            if transaction.get('state') == 'A':
                if self.blockchain:
                    latest_block = self.blockchain[-1]
                    transaction['predecessor_index'] = len(self.blockchain) - 1
                    transaction['predecessor_hash'] = latest_block.get('hash')
                else:
                    # This is the first transaction after genesis
                    transaction['predecessor_index'] = 0
                    transaction['predecessor_hash'] = "0"  # Genesis block hash

            # Handle state transitions
            if transaction.get('state') == 'B':
                # Verify that the block being validated exists
                validated_block_id = transaction.get('validated_block')
                if validated_block_id is not None and validated_block_id < len(self.blockchain):
                    validated_block = self.blockchain[validated_block_id]
                    # Set the hash_b of this block to be the hash_c of the validated block
                    transaction['hash_b'] = validated_block.get('hash_c')
                else:
                    print(f"Invalid validation attempt: Block {validated_block_id} not found")
                    return False

            elif transaction.get('state') == 'C':
                # Verify that the validating block exists
                validated_by_id = transaction.get('validated_by')
                if validated_by_id is not None and validated_by_id < len(self.blockchain):
                    validating_block = self.blockchain[validated_by_id]
                    # Set the hash_c of this block to be the hash_b of the validating block
                    transaction['hash_c'] = validating_block.get('hash_b')
                else:
                    print(f"Invalid validation attempt: Validating block {validated_by_id} not found")
                    return False

            self.mempool.append(transaction)
            print(f"Transaction {tx_signature[:8]}... added to mempool (state: {transaction.get('state')})")

        # Broadcast only if this node received it first
        if origin_peer is None:
            thread = threading.Thread(target=self._broadcast_transaction, args=(transaction,))
            thread.start()

        return True

    def get_blockchain(self) -> list:
        """Returns a copy of the blockchain."""
        with self.lock:
            return list(self.blockchain) # Return a copy

    def get_mempool(self) -> list:
        """Returns a copy of the mempool."""
        with self.lock:
            return list(self.mempool) # Return a copy

# --- Flask App ---
app = Flask(__name__)
node = None # Global node object

@app.route('/blockchain', methods=['GET'])
def get_blockchain_route():
    if node:
        return jsonify(node.get_blockchain()), 200
    return "Node not initialized", 500

@app.route('/mempool', methods=['GET'])
def get_mempool_route():
    if node:
        return jsonify(node.get_mempool()), 200
    return "Node not initialized", 500

@app.route('/add_transaction', methods=['POST'])
def add_transaction_route():
    if not node:
        return "Node not initialized", 500
    values = request.get_json()
    if not values:
        return "Missing transaction data", 400

    # Basic validation of incoming data
    required_fields = ['sender', 'receiver', 'amount', 'timestamp', 'signature']
    if not all(field in values for field in required_fields):
        return 'Missing fields in transaction data', 400

    # Check if the transaction is being broadcast from another peer
    origin_peer = request.headers.get('X-Pasta-Origin')

    # Prevent node from processing its own broadcasts reflected back
    if origin_peer == node.address:
        # print(f"Received own broadcast for tx {values.get('signature')[:8]}, ignoring.")
        return jsonify({'message': 'Ignoring own broadcast'}), 200 # Acknowledge receipt but do nothing

    # Add transaction to node's mempool (will broadcast if origin_peer is None)
    success = node.add_transaction_to_mempool(values, origin_peer=origin_peer)

    if success:
        # If the transaction was successfully added (new or from peer)
        status_code = 201 if origin_peer is None else 200 # Created if from CLI, OK if from peer
        response = {'message': 'Transaction added to mempool'}
        return jsonify(response), status_code
    else:
        # Likely already in mempool or invalid (once validation is added)
        response = {'message': 'Transaction already exists or is invalid'}
        # 409 Conflict is reasonable if it already exists
        return jsonify(response), 409


# --- Main Execution ---
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Run a PastaCoin node.')
    parser.add_argument('-p', '--port', type=int, default=5000, help='Port to run the node on.')
    parser.add_argument('--peers', nargs='*', default=[], help='List of peer node addresses (e.g., http://localhost:5001 http://localhost:5002)')
    args = parser.parse_args()

    # Initialize the node globally
    node = PastaNode(port=args.port, peers=args.peers)

    # Run Flask app
    # Use threaded=True for basic concurrency, allowing multiple requests
    # Use use_reloader=False to prevent Flask from starting twice in debug mode
    app.run(host='0.0.0.0', port=args.port, threaded=True, use_reloader=False) 