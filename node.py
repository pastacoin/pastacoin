# --- Standard Library / Third-party Imports ---
import json
import os
import threading
import time
import argparse

# Third-party packages
import requests
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS

import ecdsa
import base58
import hashlib

# Assuming fake-blockchain-gen.py and fake-mempool-gen.py might still be used
# initially to create the baseline files.
NETWORK_PATH = "C:\\PastaNetwork" # Keep for loading initial files, maybe remove later

def load_json(filename: str, default):
    # Load from the shared path for initial setup
    filepath = os.path.join(NETWORK_PATH, filename)
    if os.path.exists(filepath):
        try:
            with open(filepath, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Error decoding JSON from {filename}. Starting with default.")
            return default
    print(f"Warning: {filename} not found. Starting with default.")
    return default

class PastaNode:
    def __init__(self, port: int, peers: list[str]):
        self.port = port
        self.address = f"http://localhost:{port}" # Node's own address for identification
        self.peers = set(peers) # Known peer addresses (e.g., 'http://localhost:5001')

        # --- Node's Internal State ---
        # Load initial state from files generated by fake scripts
        self.blockchain = load_json("blockchain.json", [])
        self.mempool = load_json("mempool.json", []) # Initial mempool from file
        self.addresses = load_json("addresses.json", {}) # Maps public key to private key

        # Basic locking for thread safety
        self.lock = threading.Lock()

        # If blockchain is empty, create a genesis block
        if not self.blockchain:
            self._create_genesis_block()

        print(f"Node initialized on port {self.port} at address {self.address}")
        print(f"Initial Blockchain size: {len(self.blockchain)}")
        print(f"Initial Mempool size: {len(self.mempool)}")
        print(f"Known addresses: {len(self.addresses)}")
        print(f"Known peers: {self.peers}")

    def _broadcast_transaction(self, transaction: dict):
        """Broadcasts a transaction to all known peers."""
        with self.lock: # Ensure peers set doesn't change during iteration
            peers_to_broadcast = list(self.peers)

        if not peers_to_broadcast:
            print("No peers to broadcast to.")
            return

        print(f"Broadcasting transaction {transaction.get('signature')[:8]}... to peers: {peers_to_broadcast}")
        headers = {'Content-Type': 'application/json', 'X-Pasta-Origin': self.address}
        for peer in peers_to_broadcast:
            try:
                # Use a timeout to prevent hanging indefinitely
                response = requests.post(f"{peer}/add_transaction", headers=headers, json=transaction, timeout=1)
                response.raise_for_status()
                print(f"  -> Sent to {peer}, status {response.status_code}")
            except requests.exceptions.Timeout:
                print(f"  -> Timeout sending to {peer}")
            except requests.exceptions.RequestException as e:
                print(f"  -> Failed sending to {peer}: {e}")
            except Exception as e:
                 print(f"  -> Unexpected error sending to {peer}: {e}")


    def add_transaction_to_mempool(self, transaction: dict, origin_peer: str = None) -> bool:
        """Adds a transaction to the mempool if valid and broadcasts if it's new."""
        tx_signature = transaction.get('signature')
        if not tx_signature:
            print("Transaction missing signature.")
            return False

        with self.lock:
            # Duplicate check
            if any(tx.get('signature') == tx_signature for tx in self.mempool):
                if not origin_peer:
                    print(f"Transaction {tx_signature[:8]}... already in mempool.")
                return False

            # Set predecessor information for new transactions
            if transaction.get('state') == 'A':
                if self.blockchain:
                    latest_block = self.blockchain[-1]
                    transaction['predecessor_index'] = len(self.blockchain) - 1
                    transaction['predecessor_hash'] = latest_block.get('hash')
                else:
                    # This is the first transaction after genesis
                    transaction['predecessor_index'] = 0
                    transaction['predecessor_hash'] = "0"  # Genesis block hash

            # Handle state transitions
            if transaction.get('state') == 'B':
                # Verify that the block being validated exists
                validated_block_id = transaction.get('validated_block')
                if validated_block_id is not None and validated_block_id < len(self.blockchain):
                    validated_block = self.blockchain[validated_block_id]
                    # Set the hash_b of this block to be the hash_c of the validated block
                    transaction['hash_b'] = validated_block.get('hash_c')
                else:
                    print(f"Invalid validation attempt: Block {validated_block_id} not found")
                    return False

            elif transaction.get('state') == 'C':
                # Verify that the validating block exists
                validated_by_id = transaction.get('validated_by')
                if validated_by_id is not None and validated_by_id < len(self.blockchain):
                    validating_block = self.blockchain[validated_by_id]
                    # Set the hash_c of this block to be the hash_b of the validating block
                    transaction['hash_c'] = validating_block.get('hash_b')
                else:
                    print(f"Invalid validation attempt: Validating block {validated_by_id} not found")
                    return False

            self.mempool.append(transaction)
            print(f"Transaction {tx_signature[:8]}... added to mempool (state: {transaction.get('state')})")

            # Auto-promote to blockchain if state C (simple prototype logic)
            if transaction.get("state") == "C":
                self.blockchain.append(transaction)
                print(f"Transaction {tx_signature[:8]}... moved to blockchain (state C)")

        # Broadcast only if this node received it first
        if origin_peer is None:
            thread = threading.Thread(target=self._broadcast_transaction, args=(transaction,))
            thread.start()

        return True

    def get_blockchain(self) -> list:
        """Returns a copy of the blockchain."""
        with self.lock:
            return list(self.blockchain) # Return a copy

    def get_mempool(self) -> list:
        """Returns a copy of the mempool."""
        with self.lock:
            return list(self.mempool) # Return a copy

    # -------------------------------------------------------------------
    # Genesis Block Logic
    # -------------------------------------------------------------------

    def _create_genesis_block(self):
        """Create a simple genesis block and append to blockchain."""
        timestamp = int(time.time())
        genesis_block = {
            "index": 0,
            "sender": "genesis",
            "receiver": "genesis",
            "amount": 0,
            "timestamp": timestamp,
            "signature": "genesis_signature",
            "predecessor_index": None,
            "layer": 0,
            "previous_hash": "0",
            # Validation state fields
            "state": "C",
            "hash_a": None,
            "hash_b": None,
            "hash_c": "0",
            "validated_by": None,
            "validated_block": None,
        }

        # Simple deterministic hash (sha256 of JSON sans 'hash')
        block_copy = genesis_block.copy()
        block_copy.pop("hash", None)
        genesis_block["hash"] = self._calculate_hash(block_copy)

        self.blockchain.append(genesis_block)
        print("Genesis block created.")

    @staticmethod
    def _calculate_hash(data: dict) -> str:
        return hashlib.sha256(json.dumps(data, sort_keys=True).encode()).hexdigest()

    # -------------------------------------------------------------------
    # Convenience helpers to create/sign transactions server-side (optional)
    # -------------------------------------------------------------------

    def create_transaction_state_a(self, sender_priv: str, sender_pub: str, receiver_pub: str, amount: float) -> dict:
        """Create and sign a state-A transaction locally on the node (for API convenience)."""
        timestamp = time.time()
        # sign
        signing_key = ecdsa.SigningKey.from_string(base58.b58decode(sender_priv), curve=ecdsa.SECP256k1)
        message = f"{sender_pub}{receiver_pub}{amount}{timestamp}"
        signature = base58.b58encode(signing_key.sign(message.encode())).decode()

        tx = {
            "sender": sender_pub,
            "receiver": receiver_pub,
            "amount": amount,
            "timestamp": timestamp,
            "signature": signature,
            "state": "A",
            "hash_a": None,
            "hash_b": None,
            "hash_c": None,
            "predecessor_index": None,
            "predecessor_hash": None,
        }
        return tx

    def create_transaction_state_b(self, sender_priv: str, sender_pub: str, receiver_pub: str, amount: float, target_index: int) -> dict:
        """Create a state-B transaction that validates an existing block (by index)."""
        tx = self.create_transaction_state_a(sender_priv, sender_pub, receiver_pub, amount)
        tx["state"] = "B"
        tx["validated_block"] = target_index
        # Simple hash_b calculation: we hash tx without hash fields (prototype)
        tx["hash_b"] = self._calculate_hash({k: v for k, v in tx.items() if k not in ["hash_a", "hash_b", "hash_c"]})
        return tx

    def promote_transaction_to_state_c(self, target_tx: dict, validating_tx_index: int):
        """Mutate target_tx to state C and set hash_c."""
        target_tx["state"] = "C"
        target_tx["validated_by"] = validating_tx_index
        target_tx["hash_c"] = self._calculate_hash({k: v for k, v in target_tx.items() if k not in ["hash_a", "hash_b", "hash_c"]})

# --- Flask App Setup ---
# Serve static files from ../frontend (one level up from this file's directory)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
FRONTEND_DIR = os.path.abspath(os.path.join(BASE_DIR, os.pardir, "frontend"))

app = Flask(__name__, static_folder=FRONTEND_DIR, static_url_path="")
# Enable CORS for all domains in this early prototype
CORS(app)

node = None  # Global node object

# --------------------------- API ROUTES ------------------------------------

@app.route('/')
def serve_index():
    """Serve the frontend if present."""
    index_path = os.path.join(FRONTEND_DIR, 'index.html')
    if os.path.exists(index_path):
        return send_from_directory(FRONTEND_DIR, 'index.html')
    return "Frontend not built", 404


@app.route('/generate_keypair', methods=['GET'])
def generate_keypair_route():
    priv, pub = generate_keypair()
    return jsonify({"private_key": priv, "public_key": pub})


@app.route('/create_transaction', methods=['POST'])
def create_transaction_route():
    """Convenience endpoint: accept sender priv key & fields, then build tx and send to /add_transaction."""
    if not node:
        return "Node not initialized", 500

    data = request.get_json() or {}
    required = {"private_key", "sender", "receiver", "amount"}
    if not required.issubset(set(data)):
        return "Missing fields", 400

    tx = node.create_transaction_state_a(
        sender_priv=data["private_key"],
        sender_pub=data["sender"],
        receiver_pub=data["receiver"],
        amount=float(data["amount"]),
    )

    node.add_transaction_to_mempool(tx)
    return jsonify({"message": "Transaction created", "transaction": tx}), 201


@app.route('/blockchain', methods=['GET'])
def get_blockchain_route():
    if node:
        return jsonify(node.get_blockchain()), 200
    return "Node not initialized", 500

@app.route('/mempool', methods=['GET'])
def get_mempool_route():
    if node:
        return jsonify(node.get_mempool()), 200
    return "Node not initialized", 500

@app.route('/add_transaction', methods=['POST'])
def add_transaction_route():
    if not node:
        return "Node not initialized", 500
    values = request.get_json()
    if not values:
        return "Missing transaction data", 400

    # Basic validation of incoming data
    required_fields = ['sender', 'receiver', 'amount', 'timestamp', 'signature']
    if not all(field in values for field in required_fields):
        return 'Missing fields in transaction data', 400

    # Check if the transaction is being broadcast from another peer
    origin_peer = request.headers.get('X-Pasta-Origin')

    # Prevent node from processing its own broadcasts reflected back
    if origin_peer == node.address:
        # print(f"Received own broadcast for tx {values.get('signature')[:8]}, ignoring.")
        return jsonify({'message': 'Ignoring own broadcast'}), 200 # Acknowledge receipt but do nothing

    # Add transaction to node's mempool (will broadcast if origin_peer is None)
    success = node.add_transaction_to_mempool(values, origin_peer=origin_peer)

    if success:
        # If the transaction was successfully added (new or from peer)
        status_code = 201 if origin_peer is None else 200 # Created if from CLI, OK if from peer
        response = {'message': 'Transaction added to mempool'}
        return jsonify(response), status_code
    else:
        # Likely already in mempool or invalid (once validation is added)
        response = {'message': 'Transaction already exists or is invalid'}
        # 409 Conflict is reasonable if it already exists
        return jsonify(response), 409

# ---------------------------------------------------------------------------
#                Endpoints for advancing transaction states
# ---------------------------------------------------------------------------


@app.route('/advance_b', methods=['POST'])
def advance_b_route():
    if not node:
        return "Node not initialized", 500

    data = request.get_json() or {}
    required = {"private_key", "sender", "receiver", "amount", "target_index"}
    if not required.issubset(set(data)):
        return "Missing fields", 400

    target_idx = int(data["target_index"])
    mempool = node.get_mempool()
    if target_idx < 0 or target_idx >= len(mempool):
        return "Invalid target_index", 400

    tx_b = node.create_transaction_state_b(
        sender_priv=data["private_key"],
        sender_pub=data["sender"],
        receiver_pub=data["receiver"],
        amount=float(data["amount"]),
        target_index=target_idx,
    )

    node.add_transaction_to_mempool(tx_b)
    return jsonify({"message": "State B transaction created", "transaction": tx_b}), 201


@app.route('/advance_c', methods=['POST'])
def advance_c_route():
    if not node:
        return "Node not initialized", 500

    data = request.get_json() or {}
    required = {"private_key", "sender", "receiver", "amount", "target_index"}
    if not required.issubset(set(data)):
        return "Missing fields", 400

    target_idx = int(data["target_index"])
    mempool = node.get_mempool()
    if target_idx < 0 or target_idx >= len(mempool):
        return "Invalid target_index", 400

    # Create validating tx (state B) first
    tx_b = node.create_transaction_state_b(
        sender_priv=data["private_key"],
        sender_pub=data["sender"],
        receiver_pub=data["receiver"],
        amount=float(data["amount"]),
        target_index=target_idx,
    )

    # Add validating tx to mempool, capture its index
    node.add_transaction_to_mempool(tx_b)
    new_index = len(node.get_mempool()) - 1

    # Promote target transaction to state C
    target_tx = mempool[target_idx]
    node.promote_transaction_to_state_c(target_tx, validating_tx_index=new_index)

    # Update mempool entry (replace)
    with node.lock:
        node.mempool[target_idx] = target_tx

    return jsonify({"message": "Transaction advanced to state C", "validated_transaction": target_tx, "validating_transaction": tx_b}), 201

# --- Main Execution ---
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Run a PastaCoin node.')
    parser.add_argument('-p', '--port', type=int, default=5000, help='Port to run the node on.')
    parser.add_argument('--peers', nargs='*', default=[], help='List of peer node addresses (e.g., http://localhost:5001 http://localhost:5002)')
    args = parser.parse_args()

    # Initialize the node globally
    node = PastaNode(port=args.port, peers=args.peers)

    # Run Flask app. If Render sets a PORT environment variable, use it, otherwise fallback to CLI arg.
    port = int(os.getenv("PORT", args.port))
    # Use threaded=True for basic concurrency, allowing multiple requests
    # use_reloader=False prevents Flask from starting twice in debug/envs with auto-reload.
    app.run(host='0.0.0.0', port=port, threaded=True, use_reloader=False) 